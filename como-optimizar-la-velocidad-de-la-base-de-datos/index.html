<!DOCTYPE html>
<html>
  <head>
    <meta
      name="google-site-verification"
      content="gO0C3waQo_Srk8NAsXcUn50_hd-CY_DQb-a_ajojz-U"
    />

    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

    <title>¿Cómo optimizar la velocidad de la base de datos?</title>
    <meta
      name="description"
      content="Cuando hacemos el diseño tenemos que fijarnos en optimizar cada uno de los campos, para ello vamos a ver cada uno de los puntos a tener en cuenta"
    />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="shortcut icon" href="../assets/favicon_v%3D037246b580.png" />

    <link rel="stylesheet" type="text/css" href="../assets/css/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/style.css" />
    <link rel="stylesheet" type="text/css" href="../assets/css/miguelra.css" />

    <link
      rel="canonical"
      href="http://www.miguelra.com/como-optimizar-la-velocidad-de-la-base-de-datos/"
    />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link
      rel="amphtml"
      href="http://www.miguelra.com/como-optimizar-la-velocidad-de-la-base-de-datos/amp/"
    />

    <meta property="og:site_name" content="Miguel Rodríguez" />
    <meta property="og:type" content="article" />
    <meta
      property="og:title"
      content="¿Cómo optimizar la velocidad de la base de datos?"
    />
    <meta
      property="og:description"
      content="Cuando hacemos el diseño tenemos que fijarnos en optimizar cada uno de los campos, para ello vamos a ver cada uno de los puntos a tener en cuenta"
    />
    <meta
      property="og:url"
      content="http://www.miguelra.com/como-optimizar-la-velocidad-de-la-base-de-datos/"
    />
    <meta
      property="og:image"
      content="http://www.miguelra.com/content/images/2016/12/database.jpg"
    />
    <meta
      property="article:published_time"
      content="2016-10-09T18:08:00.000Z"
    />
    <meta property="article:modified_time" content="2016-12-08T02:17:22.000Z" />
    <meta property="article:tag" content="Optimización" />
    <meta property="article:tag" content="Bases de datos" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="¿Cómo optimizar la velocidad de la base de datos?"
    />
    <meta
      name="twitter:description"
      content="Cuando hacemos el diseño tenemos que fijarnos en optimizar cada uno de los campos, para ello vamos a ver cada uno de los puntos a tener en cuenta"
    />
    <meta
      name="twitter:url"
      content="http://www.miguelra.com/como-optimizar-la-velocidad-de-la-base-de-datos/"
    />
    <meta
      name="twitter:image"
      content="http://www.miguelra.com/content/images/2016/12/database.jpg"
    />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Miguel Rodríguez" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Optimización, Bases de datos" />

    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "publisher": {
          "@type": "Organization",
          "name": "Miguel Rodríguez",
          "logo": "http://www.miguelra.com/content/images/2016/11/logo.png"
        },
        "author": {
          "@type": "Person",
          "name": "Miguel Rodríguez",
          "image": "http://www.miguelra.com/content/images/2016/11/profile.jpg",
          "url": "http://www.miguelra.com/author/miguel/",
          "sameAs": [],
          "description": "¡Hey! Soy Miguel, tengo 24 años y soy desarrollador web, lo que más me gusta de mi trabajo es estar en constante aprendizaje, al tanto de las últimas noticias y trastear con nuevas ideas."
        },
        "headline": "¿Cómo optimizar la velocidad de la base de datos?",
        "url": "http://www.miguelra.com/como-optimizar-la-velocidad-de-la-base-de-datos/",
        "datePublished": "2016-10-09T18:08:00.000Z",
        "dateModified": "2016-12-08T02:17:22.000Z",
        "image": "http://www.miguelra.com/content/images/2016/12/database.jpg",
        "keywords": "Optimización, Bases de datos",
        "description": "Cuando hacemos el diseño tenemos que fijarnos en optimizar cada uno de los campos, para ello vamos a ver cada uno de los puntos a tener en cuenta",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "http://www.miguelra.com"
        }
      }
    </script>

    <script
      type="text/javascript"
      src="../shared/ghost-url.min_v%3D037246b580.js"
    ></script>
    <script type="text/javascript">
      ghost.init({
        clientId: "ghost-frontend",
        clientSecret: "d1a707dee088",
      });
    </script>
    <meta name="generator" content="Ghost 0.11" />
    <link
      rel="alternate"
      type="application/rss+xml"
      title="Miguel Rodríguez"
      href="http://www.miguelra.com/rss/"
    />
  </head>

  <body class="post-template tag-optimizacion tag-bases-de-datos">
    <header
      id="masthead"
      class="
        blog-background
        overlay
        align-center align-middle
        animated
        from-bottom
      "
      style="background-image: url(../content/images/2016/12/database.jpg)"
    >
      <div class="inner">
        <div class="container">
          <a class="brand light" href="http://www.miguelra.com" role="banner">
            <img src="../content/images/2016/11/logo.png" alt="Blog Logo" />
          </a>
          <h1 class="blog-title light">Miguel Rodríguez</h1>
          <h2 class="blog-description light bordered bordered-top"></h2>
        </div>
      </div>
      <div class="decor-wrapper">
        <svg
          id="header-decor"
          class="decor bottom"
          xmlns="http://www.w3.org/2000/svg"
          version="1.1"
          viewBox="0 0 100 100"
          preserveAspectRatio="none"
        >
          <path
            class="large left"
            d="M0 0 L50 50 L0 100"
            fill="rgba(255,255,255, .1)"
          />
          <path
            class="large right"
            d="M100 0 L50 50 L100 100"
            fill="rgba(255,255,255, .1)"
          />

          <path
            class="medium left"
            d="M0 100 L50 50 L0 33.3"
            fill="rgba(255,255,255, .3)"
          />
          <path
            class="medium right"
            d="M100 100 L50 50 L100 33.3"
            fill="rgba(255,255,255, .3)"
          />

          <path
            class="small left"
            d="M0 100 L50 50 L0 66.6"
            fill="rgba(255,255,255, .5)"
          />
          <path
            class="small right"
            d="M100 100 L50 50 L100 66.6"
            fill="rgba(255,255,255, .5)"
          />

          <path
            d="M0 99.9 L50 49.9 L100 99.9 L0 99.9"
            fill="rgba(255,255,255, 1)"
          />

          <path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)" />
        </svg>
      </div>
    </header>

    <div id="main" class="content" role="main">
      <div class="container">
        <div class="row">
          <article
            class="post tag-optimizacion tag-bases-de-datos post post col-md-9"
          >
            <header class="post-header">
              <h1 class="post-title text-center hyper lighter bordered-bottom">
                ¿Cómo optimizar la velocidad de la base de datos?
              </h1>
              <div class="post-info text-center small">
                <time datetime="2016-10-09" class="post-time">09/10/2016</time>
                en
                <span class="post-tags"
                  ><a href="../tag/optimizacion/">Optimización</a>,
                  <a href="../tag/bases-de-datos/">Bases de datos</a></span
                >
              </div>
            </header>
            <div class="post-body bordered-bottom">
              <div class="addthis_inline_share_toolbox"></div>
              <p>
                Continuando la serie de artículos que empezamos con <a
                  href="https://miguelra.com/mejorar-la-velocidad-una-web/"
                  >Cómo mejorar la velocidad de una web</a
                >, hoy vamos a hablar de como optimizar nuestra base de datos,
                tanto si  estamos limpiando tablas antiguas o creando nuevos
                índices para un acceso más rápido, siempre hay cosas que se
                pueden optimizar. Creo que lo mejor para este tema es separarlo
                en dos apartados claramente diferenciados:
              </p>

              <ul>
                <li>
                  <strong>Optimizar base de datos</strong>: Configuración y
                  diseño de nuestra base de datos.
                </li>
                <li>
                  <strong>Optimizar consultas a base de datos:</strong> Acciones
                  que realizamos en la base de datos y comandos mas eficientes.
                </li>
              </ul>

              <p>
                <img
                  src="../content/images/2016/12/13282446.jpg"
                  alt="Challenge accepted"
                />
              </p>

              <h2 id="cmooptimizarbasededatos">
                ¿Cómo optimizar base de datos?
              </h2>

              <p>
                Lo más importante es crear nuestra base de datos, sin base de
                datos no hay nada que optimizar :P
              </p>

              <h3 id="creardiseodebasededatosajustndonosalosrequerimientos">
                Crear diseño de base de datos, ajustándonos a los
                requerimientos.
              </h3>

              <p>
                Cuando hacemos el diseño tenemos que fijarnos en optimizar cada
                uno de los campos, para ello vamos a ver cada uno de los puntos
                que tenemos que tener en cuenta:
              </p>

              <h3 id="usartamaosestticos">Usar tamaños estáticos</h3>

              <p>
                Si tenemos que almacenar el DNI de un usuario siempre va a tener
                9 dígitos, por lo que tendríamos que usar un CHAR(9), ya que si
                usáramos un VARCHAR, implicaría perder más tiempo ya que
                su lectura, indización y almacenamiento es más complejo al tener
                un tamaño variable.
              </p>

              <div class="overflow-scroll">
                <table class="table table-striped">
                  <thead>
                    <tr>
                      <th>Valor</th>
                      <th>CHAR(9)</th>
                      <th>Almacenamiento</th>
                      <th>VARCHAR(9)</th>
                      <th>Almacenamiento</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>''</td>
                      <td>'         '</td>
                      <td>9 bytes</td>
                      <td>''</td>
                      <td>1 byte</td>
                    </tr>
                    <tr>
                      <td>'62384'</td>
                      <td>'62348    '</td>
                      <td>9 bytes</td>
                      <td>'62348'</td>
                      <td>6 bytes</td>
                    </tr>
                    <tr>
                      <td>'39238375D'</td>
                      <td>'39238375D'</td>
                      <td>9 bytes</td>
                      <td>'39238375D'</td>
                      <td>10 bytes</td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <p>
                Como vemos si tenemos claro el tamaño es mejor usar un
                <strong>tamaño estático</strong>. Introduciendo este tema
                llamamos <strong>tabla fija o estáticas</strong> a las que todos
                los campos tienen un tamaño fijo, este tipo de tablas son mas
                eficientes ya que al realizar las consultas saben cual es el
                tamaño del campo, donde empiezan el valor en memoria y no tiene
                que realizar consultas innecesarias. Una técnica para separar
                los campos de tamaño variable es el
                <strong>particionado vertical</strong>, que veremos a
                continuación
              </p>

              <h3 id="particionalastablas">Particiona las tablas</h3>

              <p>
                o <strong>particionado vertical</strong>, puede ser un arma de
                doble filo y tenemos que tener muy claro que los campos que
                vamos a separar no los vamos a necesitar juntar frecuentemente o
                perjudicará a nuestro rendimiento. Dicho esto nos puede ayudar
                en dos casos:
              </p>

              <ul>
                <li>
                  <strong>Evitar actualizar caché</strong>: Si tenemos una tabla
                  usuarios que registra la última conexión del usuario, puede
                  ser interesante tener una tabla a parte para que cada vez que
                  un usuario inicie sesión, no tengamos que volver a actualizar
                  la caché.
                </li>
                <li>
                  <strong>Hacer tablas mas pequeñas</strong>: Por otro lado si
                  tenemos una tabla de usuarios que se usa para el login y
                  queremos almacenar datos personales, podemos separar por
                  frecuencia los campos que más usamos.
                </li>
              </ul>

              <h3 id="loscamposcortossonmsrpidos">
                Los campos cortos son más rápidos
              </h3>

              <p>
                Como vemos en la documentación de MySQL, en la sección de
                <a
                  href="http://ftp.nchu.edu.tw/MySQL/doc/refman/5.0/es/storage-requirements.html"
                  >requerimientos de almacenamiento</a
                > nos indica cuanto espacio en memoria consume cada tipo de
                dato. Por lo que cuanto menos bytes tenga que procesar nuestra
                base de datos pues mejor :D
              </p>

              <h3 id="tenerclarocuandousarndices">
                Tener claro cuando usar índices
              </h3>

              <p>
                Siempre tenemos que tener algún campo indexado en nuestras
                tablas pero tenemos que tener claro que agregar índices para
                solucionar consultas lentas, no es la solución.
              </p>

              <ul>
                <li>Los índices no son solo para campos únicos o primarios</li>
                <li>Las columnas con índice único son mucho más rápidas</li>
                <li>
                  Las búsquedas de una cadena dentro de un campo, no se ven
                  afectadas por la indexación
                </li>
              </ul>

              <pre><code class="language-sql">//Se ve afectado por los indices
… WHERE campo LIKE "cadena%";
//No se ve afectado por lo indices
… WHERE campo LIKE "%cadena%";
//Tenemos que evitar este tipo de consultas ya que son muy costosas
</code></pre>

              <p>
                Como conclusión podemos decir que el uso de los índices está
                pensado para usarlos con campos que se consultan con mucha
                frecuencia, se realizan agrupamientos, ordenamientos o joins.
              </p>

              <h3 id="evitaloscamposnull">Evita los campos NULL</h3>

              <p>
                Tenemos que valorar si realmente hay diferencia para nuestro
                caso actual usar un campo vacío en lugar de NULL ya que, agrega
                información adicional a nuestro campo y puede llegar a complicar
                nuestras consultas. Aun que si comparamos Oracle con MySQL vemos
                tratan de distinto modo este tema:
              </p>

              <ul>
                <li>
                  <strong>Oracle</strong>: No hace diferencia entre campos nulos
                  y vacíos
                </li>
                <li>
                  <strong>MySQL</strong>: Las columnas NULL requieren espacio
                  adicional en la fila a grabar donde los valores son NULL. Para
                  las tablas MyISAM, cada columna NULL toma un bit extra,
                  redondeando hacia arriba al byte más cercano.
                </li>
              </ul>

              <h3 id="almacenalasdireccionesipcomounsignedint">
                Almacena las direcciones IP como UNSIGNED INT
              </h3>

              <p>
                Puede que lo más frecuente sea pensar en una ip como 15
                caracteres y por consecuencia asignarle CHAR(15) a nuestro
                campo, pero si nos paramos a analizar nos fijamos que podemos
                guardarlo como entero sin signo ya que cubre la longitud deseada
                al aplicarle las siguientes funciones:
              </p>

              <p>
                INET<em>ATON() e INET</em>NTOA() en
                <strong>MySQL</strong> o ip2long() y long2ip() en
                <strong>PHP</strong>
              </p>

              <p>Veamos un ejemplo:</p>

              <pre><code class="language-sql">SELECT INET_ATON("209.207.224.40");  
+-----------------------------+
| INET_ATON("209.207.224.40") |
+-----------------------------+
|                  3520061480 |
+-----------------------------+
1 row in set (0.00 sec)  
</code></pre>

              <p>
                Lo que estaría realizando la función sería la siguiente
                operación: <br />
                209<em>256^3 + 207</em>256^2 + 224*256 +40.
              </p>

              <h3 id="usarenumenlugardevarchar">
                Usar ENUM en lugar de VARCHAR
              </h3>

              <p>
                Si sabemos que vamos a usar unos valores específicos para el
                campo, la mejor opción es usar ENUM, son campos
                <strong>mucho más rápidos</strong> y
                <strong>compactos</strong> ya que se almacenan como un TINYINT.
                Hay un procedimiento en MySQL para detectar estos casos y que
                nos ayuda a <strong>analizar nuestra base de datos</strong>,
                dándonos sugerencias de que el tipo de una columna no es el
                adecuado. Para usarlo haremos uso de la llamada al procedimiento
                <strong>PROCEDURE ANALYSE()</strong>, que analizaremos a
                continuación.
              </p>

              <h3 id="usaprocedureanalyseparaobtenersugerencias">
                Usa PROCEDURE ANALYSE(), para obtener sugerencias
              </h3>

              <p>
                Por ejemplo, si creaste un campo INT para tu clave primaria,
                pero no tienes muchas filas, podría sugerirte que uses MEDIUMINT
                en su lugar. O si estas usando un campo VARCHAR, podría
                sugerirte que lo conviertas en ENUM, si sólo estás escribiendo
                unos pocos valores. Hay que tener en cuenta que son sugerencias
                y que solo nosotros sabes la manera en la que va a crecer
                nuestra base de datos, por lo que la decisión de implementar los
                cambios puede ser buena o mala idea.
              </p>

              <h3 id="optimizacindemysql">Optimización de MySQL</h3>

              <p>
                La optimización de MySQL también es muy importante. Aun que es
                muy variable dependiendo de nuestra aplicación, por lo que
                tenemos que analizar los valores de nuestra configuración. El
                archivo de configuración de MySQL / MariaDB normalmente se
                encuentra en <strong>/etc/my.cnf</strong>. Algunas de las
                opciones que tenemos que tener en cuenta son las siguientes.
              </p>

              <ul>
                <li>
                  <strong>tmp<em>table</em>size:</strong>Indica el tamaño que
                  tiene la tabla temporal antes de que MySQL pase a memoria
                  como tabla MyISAM. (Siendo el acceso a memoria mucho mas lento
                  que el acceso a disco)
                </li>
                <li>
                  <strong>max<em>heap</em>table_size</strong>: Controla el
                  tamaño máximo que puede consumir una tabla en memoria.
                </li>
                <li>
                  <strong>query<em>cache</em>type</strong>: Habilita la caché.
                </li>
                <li>
                  <strong>query<em>cache</em>size</strong>: Indica el tamaño de
                  la caché, muy útil cuando tenemos muchas lecturas intensivas,
                  devolviendo el mismo resultado cada vez, su valor suele ir
                  entre los 32M y 512M. Aun que puede no ser interesante si
                  cuando queremos acceder a nuestra caché, se produce un fallo
                  de caché y hay que ir a buscar el dato a disco, por lo que es
                  interesante analizarlo para cada caso.
                </li>
                <li>
                  <strong>table<em>cache</em></strong
                  >: Por defecto tiene el valor 64 e indica el número de tablas
                  abiertas por cada threads. Cuanto mayor es este número menos
                  fallos de caché obtendremos, pero tenemos que fijarnos bien
                  que valor le tenemos que dar para no desperdiciar memoria.
                  Este tamaño tiene que ser mayor al número de tablas de nuestra
                  base de datos y nos podemos ayudar de <strong
                    >OpenedTables</strong
                  >
                  para comprobar si el valor es correcto. Opened<em
                    >Tables nos indica la
                    <strong>rapidez de creación de las tablas</strong>, por lo
                    que si es muy elevado probablemente nuestro table</em
                  >cache sea muy pequeño.
                </li>
                <li>
                  <strong>thread<em>cache</em>size</strong>: Número de threads
                  que el servidor cachea para reusar, mejora el rendimiento si
                  se tienen muchas conexiones. Si un usuario se desconecta pone
                  los threads en la caché si queda espacio.
                </li>
                <li>
                  <strong>key<em>buffer</em>size</strong>: Indica el tamaño del
                  bufer que usan los bloques de indices, el tamaño máximo es de
                  4GB
                </li>
                <li>
                  <strong><em>*join_buffer_size</em>*</strong>: Indica el tamaño
                  del bufer usado para joins sin índices y otros casos.
                </li>
                <li>
                  <strong>sort<em>buffer</em>size</strong>: Indica el tamaño del
                  bufer que se usa para ordenar los resultados, está alojado en
                  cada thread cuando necesita realizar la ordenación.
                </li>
                <li>
                  <strong>read<em>buffer</em>size</strong>: Indica el tamaño del
                  bufer usado para leer tablas.
                </li>
                <li>
                  <strong>thread_stack</strong>: Indica el tamaño de la pila por
                  cada thread, el tamaño por defecto es lo suficientemente alto
                  para un buen funcionamiento, si estamos trabajando con
                  consultas muy complejas tendríamos que subir el valor.
                </li>
              </ul>

              <p>Podemos saber el valor actual de cada opción con:</p>

              <pre><code class="language-sql">show global variables like 'tmp_table_size';  
</code></pre>

              <p>
                Además de estos parámetros existe un script
                <a href="http://mysqltuner.com/">MySQL Tuner</a> que basándose
                en los logs de MySQL de nuestro servidor nos ofrece una
                configuración recomendada.
              </p>

              <h3 id="cuntamemorialedamosanuestrabasededatos">
                ¿Cuánta memoria le damos a nuestra base de datos?
              </h3>

              <p>
                Pues después de todas las explicaciones vamos a ver como con los
                valores que acabamos de ver, podemos calcular de una manera
                optima el valor para la memoria de nuestra base de datos. <br />
                <strong>Formula mágica para memoria MySQL</strong> =
                key<em>buffer</em>size + max<em>connections * (join</em
                >buffer<em>size + read</em>buffer<em>size + sort</em>buffer<em
                  >size + thread</em
                >stack + tmp<em>table</em>size)
              </p>

              <h2 id="cmooptimizarconsultasdebsqueda">
                ¿Cómo optimizar consultas de búsqueda?
              </h2>

              <p>
                Para explicar mejor los puntos que afectan en la velocidad, voy
                a hacer uso de una base de pruebas que proporciona MySQL,con
                gran cantidad de registros para poder poner ejemplos de las
                consultas (<a href="http://dev.mysql.com/doc/index-other.html"
                  >Documentación mysql</a
                >/<a href="https://github.com/datacharmer/test_db"
                  >Repositorio github</a
                >).
              </p>

              <h3 id="aprovechaalmximolacach">Aprovecha al máximo la caché</h3>

              <p>
                Casi todos los servidores de MySQL tienen activo el sistema
                caché que nos ayuda a mejorar el rendimiento de la base de
                datos. El problema es que muchas veces no nos damos cuenta de
                que no lo estamos usando de la manera correcta.
              </p>

              <pre><code class="language-sql">// Cache no funciona
SELECT first_name FROM employees WHERE birth_date &lt;= CURDATE();

// Cache funciona
SELECT first_name FROM employees WHERE birth_date &lt;= '2016-10-10';  
</code></pre>

              <p>
                Todos estos problemas suceden con todas las funciones de
                resultados variantes, otro ejemplo sería RAND() o NOW(), y
                tendríamos que considerar optimizar la consulta o deshabilitar
                la caché para la consulta.
              </p>

              <h3 id="nousarselect">No usar SELECT *</h3>

              <p>
                Puede que en el momento que escribas la consulta necesites todos
                los datos, pero en un futuro seguramente no muy lejano (<em
                  >la vida del ingeniero de software :P</em
                >) la tabla sufra algunos cambios.
                <img
                  src="https://elrinconde.miguelra.com/wp-content/uploads/2016/10/life-of-a-software-developer.jpg"
                  alt="life-of-a-software-developer"
                  title
                />
                Lo que implicaría:
              </p>

              <ul>
                <li>
                  Traer datos innecesarios que aumenta el tiempo de realizar
                  todas las consultas a disco para obtener los datos.
                </li>
                <li>Posibles problemas de seguridad.</li>
              </ul>

              <h3 id="usarjoinenlugardeencadenarselect">
                Usar JOIN en lugar de encadenar SELECT
              </h3>

              <p>
                El anidamiento de SELECT, a parte de generar código ilegible y
                difícil de seguir casi siempre ofrece un peor rendimiento frente
                al uso de JOIN.
              </p>

              <pre><code class="language-sql">// Usando IN
SELECT first_name  
FROM employees  
WHERE emp_no IN (  
    SELECT emp_no
    FROM titles
    WHERE title LIKE 'Staff%'
);

// Mejor opción usando JOIN
SELECT first_name  
FROM employees as e  
INNER JOIN titles as t ON (e.emp_no = t.emp_no)  
WHERE t.title LIKE 'Staff%';  
</code></pre>

              <p>
                También es importante destacar que si se utilizan indices en las
                columnas se debe utilizar el mismo tipo ya que MySQL solo será
                capaz de usar una de las columnas con índices en la comparación.
              </p>

              <h3 id="limitarresultado">Limitar resultado</h3>

              <p>
                Cuando tengamos claro el número de resultados que queremos
                podemos hacer uso de LIMIT que nos devuelve la cantidad de
                resultados que queremos, Además de mejorar la velocidad de la
                consulta ayudarás a minimizar el daño que puede ocasionar un
                ataque SQL de este tipo.
              </p>

              <pre><code class="language-sql">SELECT first_name FROM employees;  
300024 rows in set (0,08 sec)

SELECT first_name FROM employees LIMIT 10;  
10 rows in set (0,00 sec)  
</code></pre>

              <h3 id="orderbyrandeseldiablo">
                ORDER BY RAND() es el diablo 👹
              </h3>

              <p>
                Muchas veces puede ser un recurso interesante cuando queremos
                obtener los resultados de manera aleatoria, pero es una función
                que crece de manera exponencial y puede provocar verdaderos
                cuellos de botella en nuestras aplicaciones.
              </p>

              <h3 id="analizatusconsultas">Analiza tus consultas</h3>

              <p>
                El uso de
                <a
                  href="http://dev.mysql.com/doc/refman/5.7/en/using-explain.html"
                  >EXPLAIN</a
                > nos muestra detalles internos de nuestras tablas, con los
                cuales podemos analizar y hacer mejoras para conseguir que
                nuestras consultas complejas sean más rápidas. El resultado de
                una query EXPLAIN nos muestra los índices que se utilizan, cómo
                se explora la tabla, cómo se está ordenando, etc…
              </p>

              <h3 id="dividelasconsultasdeleteoinsertgrandes">
                Divide las consultas DELETE o INSERT grandes
              </h3>

              <p>
                Cuando tenemos una aplicación muy grande y con muchos usuarios
                simultáneos, hacer operaciones puede resultar muy costoso para
                nuestro servidor, pudiendo dejar nuestra aplicación bloqueada
                durante un periodo de tiempo o estropeando nuestro servidor Una
                solución para estos problemas es realizar nuestras operaciones
                por bloques haciendo uso de LIMIT en nuestras sentencias DELETE,
                o separar por bloques los inserts.
              </p>

              <pre><code class="language-sql">DELETE FROM salaries WHERE to_date &lt;= '2000-01-01' LIMIT 10000;  
</code></pre>

              <h3 id="optimizarconsultasaunatablaconmuchosregistros">
                Optimizar consultas a una tabla con muchos registros
              </h3>

              <p>
                Existe una técnica que se usa cuando estamos tratando gran
                volumen de datos llamada "<strong>Sharding</strong>" o partición
                horizontal, que trata de dividir nuestros registros en distintas
                tablas consiguiendo un acceso a los datos mucho más rápido. Para
                particionar nuestra tabla lo tenemos que hacer con cierta
                consistencia, para que los datos quede agrupados. Por ejemplo:
              </p>

              <ul>
                <li>Ubicación geográfica</li>
                <li>Alfabeticamente</li>
              </ul>
            </div>

            <footer class="post-footer">
              <div class="post-share text-center">
                <p class="light">
                  ¿Te ha gustado este artículo? compartelo para que más gente
                  también pueda leerlo ☺️
                </p>
                <div class="addthis_inline_share_toolbox_ypuz"></div>
              </div>

              <div class="post-author text-center">
                <img
                  src="../content/images/2016/11/profile.jpg"
                  itemprop="image"
                  class="post-avatar img-circle img-responsive"
                />
                <h4 class="bordered-bottom">Miguel Rodríguez</h4>
                <p>
                  ¡Hey! Soy Miguel, tengo 24 años y soy desarrollador web, lo
                  que más me gusta de mi trabajo es estar en constante
                  aprendizaje, al tanto de las últimas noticias y trastear con
                  nuevas ideas.
                </p>
              </div>

              <div class="post-comments text-center">
                <div id="disqus_thread"></div>
                <script>
                  (function () {
                    // DON'T EDIT BELOW THIS LINE
                    var d = document,
                      s = d.createElement("script");
                    s.src = "//miguelra.disqus.com/embed.js";
                    s.setAttribute("data-timestamp", +new Date());
                    (d.head || d.body).appendChild(s);
                  })();
                </script>
              </div>
            </footer>
          </article>
        </div>
      </div>
    </div>

    <div class="reading-time-indicator js-post-sticky-footer">
      <div class="post-reading-time visible js-post-reading-time">
        <div class="percent js-percent-count">0%</div>
        <progress value="0" class="read-progress-indicator single">
          <div class="progress-container">
            <span class="progress-bar"></span>
          </div>
        </progress>
        <div class="read-estimation">
          <div class="read-estimation-content">
            <div class="title">
              ¿Cómo optimizar la velocidad de la base de datos?
            </div>
            <div class="estimated-time">
              <span class="js-word-count"></span> palabras -
              <span class="eta"></span>.
            </div>
          </div>
        </div>
      </div>
      <div class="js-prev-next-post prev-next-post">
        <div class="prev-block">
          <a href="../como-mejorar-la-velocidad-de-una-web/">
            <span class="image">
              <img
                src="../content/images/2016/12/speed.jpg"
                class="post-image-thumbnail"
              />
            </span>
            <span class="description">
              <span class="prev-next-label">Anterior</span>
              <span class="post-title"
                >Cómo mejorar la velocidad de una web</span
              >
            </span>
          </a>
        </div>
        <div class="next-block">
          <a href="../como-instalar-ghost/">
            <span class="image">
              <img
                src="../content/images/2016/11/ghost.jpg"
                class="post-image-thumbnail"
              />
            </span>
            <span class="description">
              <span class="prev-next-label">Siguiente</span>
              <span class="post-title">Cómo instalar Ghost</span>
            </span>
          </a>
        </div>
      </div>
    </div>

    <footer
      id="footer"
      class="blog-background overlay text-center align-middle animated from-top"
      style="
        background-image: url(../content/images/2016/12/background-coding.jpg);
      "
    >
      <div class="inner">
        <div class="container">
          <ul class="social-icons">
            <li>
              <a href="https://github.com/miguel-ra">
                <i class="icon-github"></i>
              </a>
            </li>
            <li>
              <a href="http://codepen.io/miguelra/">
                <i class="icon-codepen"></i>
              </a>
            </li>
            <li>
              <a href="https://twitter.com/theRollerShark">
                <i class="icon-twitter"></i>
              </a>
            </li>
            <li>
              <a href="http://www.facebook.com/miguelrodriguezamarelle">
                <i class="icon-facebook"></i>
              </a>
            </li>
            <li>
              <a href="https://es.linkedin.com/in/miguelrodriguezamarelle">
                <i class="icon-linkedin"></i>
              </a>
            </li>
          </ul>
          <p class="copy-text">Copyright © 2016 MiguelRA.</p>
        </div>
      </div>
      <div class="decor-wrapper">
        <svg
          id="footer-decor"
          class="decor top"
          xmlns="http://www.w3.org/2000/svg"
          version="1.1"
          viewBox="0 0 100 100"
          preserveAspectRatio="none"
        >
          <path
            class="large left"
            d="M0 0 L50 50 L0 100"
            fill="rgba(255,255,255, .1)"
          />
          <path
            class="large right"
            d="M100 0 L50 50 L100 100"
            fill="rgba(255,255,255, .1)"
          />

          <path
            class="medium left"
            d="M0 0 L50 50 L0 66.6"
            fill="rgba(255,255,255, .3)"
          />
          <path
            class="medium right"
            d="M100 0 L50 50 L100 66.6"
            fill="rgba(255,255,255, .3)"
          />

          <path
            class="small left"
            d="M0 0 L50 50 L0 33.3"
            fill="rgba(255,255,255, .5)"
          />
          <path
            class="small right"
            d="M100 0 L50 50 L100 33.3"
            fill="rgba(255,255,255, .5)"
          />

          <path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)" />

          <path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)" />
        </svg>
      </div>
    </footer>

    <script
      type="text/javascript"
      src="https://code.jquery.com/jquery-1.12.0.min.js"
    ></script>
    <script
      type="text/javascript"
      src="../assets/vendor/polyfills/promise.min_v%3D037246b580.js"
    ></script>
    <script type="text/javascript">
      var load = (function () {
        function _load(tag) {
          return function (url) {
            // This promise will be used by Promise.all to determine success or failure
            return new Promise(function (resolve, reject) {
              var element = document.createElement(tag);
              var parent = "body";
              var attr = "src";

              // Important success and error for the promise
              element.onload = function () {
                resolve(url);
              };
              element.onerror = function () {
                reject(url);
              };

              // Need to set different attributes depending on tag type
              switch (tag) {
                case "script":
                  element.async = true;
                  break;
                case "link":
                  element.type = "text/css";
                  element.rel = "stylesheet";
                  attr = "href";
                  parent = "head";
              }

              // Inject into document to kick off loading
              element[attr] = url;
              document[parent].appendChild(element);
            });
          };
        }

        return {
          css: _load("link"),
          js: _load("script"),
        };
      })();

      (function loadFiles() {
        load.css("/assets/vendor/prism/css/prism.css?v=037246b580");
        load.css("/assets/vendor/sweetalert/sweetalert.css?v=037246b580");

        Promise.all([
          load.js("/assets/vendor/polyfills/fetch.min.js?v=037246b580"),
          load.js("/assets/vendor/waypoints/waypoints.min.js?v=037246b580"),
          load.js("/assets/vendor/bootstrap/bootstrap.min.js?v=037246b580"),
          load.js("/assets/vendor/sweetalert/sweetalert.min.js?v=037246b580"),
          load.js("/assets/vendor/readingtime/readingtime.min.js?v=037246b580"),
          load.js("/assets/vendor/ghosthunter/ghostHunter.min.js?v=037246b580"),
          load.js(
            "/assets/vendor/imagesloaded/imagesloaded.min.js?v=037246b580"
          ),
        ]).then(function () {
          load.js("/assets/js/script.js?v=037246b580").then(function () {
            load.js(
              "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-584883ec5377771d&domready=1"
            );
            load.js("/assets/vendor/prism/js/prism.min.js?v=037246b580");
          });
        });
      })();
    </script>
  </body>
</html>
